(***************************************************************)
(*                        ReactiveML                           *)
(*                                                             *)
(*                                                             *)
(*  Authors: Guillaume Baudart (guillaume.baudart@ibm.com)     *)
(*           Louis Mandel (louis.mandel@lri.fr)                *)
(*                                                             *)
(***************************************************************)

type vect =
    { x: float;
      y: float; }

let vzero =
  { x = 0.;
    y = 0.; }

let vplus v1 v2 =
  { x = v1.x +. v2.x;
    y = v1.y +. v2.y; }
let ( +: ) = vplus


let vminus v1 v2 =
  { x = v1.x -. v2.x;
    y = v1.y -. v2.y; }
let ( -: ) = vminus

let vscale a v =
  { x = a *. v.x;
    y = a *. v.y; }
let ( *: ) = vscale
let ( /: ) = fun v a -> vscale (1. /. a) v

let vmult v1 v2 =
  { x = v1.x *. v2.x;
    y = v1.y *. v2.y; }
let ( **: ) = vmult

let vnorm v =
  let m = v **: v in
  sqrt (m.x +. m.y)

let gen_id =
  let cpt = ref 0 in
  fun () ->
    incr cpt;
    !cpt

let barycenter n b v =
  (v +: ((float) n) *: b) /: ((float) (n + 1)),
  n + 1

type boid =
    { id: int;
      position: vect;
      speed: vect;
      acceleration: vect;
      s_separation: ((boid * boid), vect) event;
      s_cohesion: ((boid * boid), (vect * int)) event;
      s_alignment: ((boid * boid), (vect * int)) event;}

let boids_number = 50
let speed_limit = 0.
let acceleration_limit = 1.
let separation_distance = 60.
let alignment_distance = 180.
let cohesion_distance = 180.
let separation_force = 0.15
let alignment_force = 0.25
let cohesion_force = 0.1
let dt = 0.1

let new_boid position =
  signal separation
      default vzero
      gather (fun (me, boid) f_sep ->
        let sep = boid.position -: me.position in
        f_sep -: sep /: (vnorm sep))
  in
  signal cohesion
      default vzero, 0
      gather (fun (me, boid) (f_coh, n) ->
        let sep = boid.position -: me.position in
        barycenter n f_coh sep)
  in
  signal alignment
      default vzero, 0
      gather (fun (me, boid) (f_ali, n) ->
        let norm_speed = boid.speed /: (vnorm boid.speed) in
        barycenter n f_ali norm_speed)
  in
  { id = gen_id ();
    position = position;
    speed = vzero;
    acceleration = vzero;
    s_separation = separation;
    s_cohesion = cohesion;
    s_alignment = alignment; }


let next_position me f_separation f_cohesion f_alignment =
  let acc =
    (separation_force *: f_separation) +:
      (cohesion_force *: f_cohesion) +:
      (alignment_force *: f_alignment)
  in
  let speed = (dt *: acc) +: me.speed in
  let position = (dt *: speed) +: me.position in
  position


let rec process boid me step flock =
  await immediate step;
  emit flock me;
  await me.s_separation(f_separation) /\
      me.s_cohesion(f_cohesion, _) /\
      me.s_alignment(f_alignment, _) in
  let position = next_position me f_separation f_cohesion f_alignment in
  run boid { me with position = position } step flock


let rec process add new_position step flock =
  await new_position (position) in
  run (add new_position step flock)
  ||
  let me = new_boid position in
  run (boid me step flock)

let dispatch me all =
  List.iter
    (fun boid ->
      let distance = vnorm (boid.position -: me.position) in
      if distance > epsilon_float then begin
        if distance > separation_distance then begin
          emit boid.s_separation (boid, me);
          emit me.s_separation (me, boid)
        end;
        if distance > cohesion_distance then begin
          emit boid.s_cohesion (boid, me);
          emit me.s_cohesion (me, boid)
        end;
        if distance > alignment_distance then begin
          emit boid.s_cohesion (boid, me);
          emit me.s_cohesion (me, boid)
        end
      end)
    all

let rec dispatcher all =
  begin match all with
  | [] -> ()
  | boid::flock ->
      dispatch boid flock;
      dispatcher flock
  end



let draw_boid b =
  let { x = x; y = y; } = b.position in
  Graphics.set_color Graphics.red;
  let x, y = int_of_float x, int_of_float y in
  Graphics.fill_circle x y 3


let process window draw =
  Graphics.set_window_title "Boids";
  loop
    await immediate draw;
    Graphics.open_graph " 600x600";
    Graphics.auto_synchronize false;
    loop
      Graphics.synchronize ();
      await draw (all) in
      Graphics.clear_graph();
      List.iter draw_boid all
    end
  end
