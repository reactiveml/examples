(***************************************************************)
(*                        ReactiveML                           *)
(*                                                             *)
(*                                                             *)
(*  Authors: Guillaume Baudart (guillaume.baudart@ibm.com)     *)
(*           Louis Mandel (louis.mandel@lri.fr)                *)
(*                                                             *)
(***************************************************************)

type vect =
    { x: float;
      y: float; }

let vzero =
  { x = 0.;
    y = 0.; }

let vplus v1 v2 =
  { x = v1.x +. v2.x;
    y = v1.y +. v2.y; }
let ( +: ) = vplus


let vminus v1 v2 =
  { x = v1.x -. v2.x;
    y = v1.y -. v2.y; }
let ( -: ) = vminus

let vscale a v =
  { x = a *. v.x;
    y = a *. v.y; }
let ( *: ) = vscale
let ( /: ) = fun v a -> vscale (1. /. a) v

let vmult v1 v2 =
  { x = v1.x *. v2.x;
    y = v1.y *. v2.y; }
let ( **: ) = vmult

let vnorm v =
  let m = v **: v in
  sqrt (m.x +. m.y)

let vrandom xmax ymax =
  { x = Random.float xmax;
    y = Random.float ymax; }

let vprint v =
  print_endline ("("^(string_of_float v.x)^","^(string_of_float v.y)^")")

let gen_id =
  let cpt = ref 0 in
  fun () ->
    incr cpt;
    !cpt

let barycenter n b v =
  (v +: ((float) n) *: b) /: ((float) (n + 1)),
  n + 1

type boid =
    { id: int;
      position: vect;
      speed: vect;
      acceleration: vect;
      s_separation: ((boid * boid), vect) event;
      s_cohesion: ((boid * boid), (vect * int)) event;
      s_alignment: ((boid * boid), (vect * int)) event;}

let boids_number = 50
let speed_limit = 0.
let acceleration_limit = 1.
let separation_distance = 60.
let alignment_distance = 180.
let cohesion_distance = 180.
let separation_force = 0.00000015
let alignment_force = 0.00000025
let cohesion_force = 0.0000001
let dt = 0.1
let bounds = (0., 600., 0., 600.)

let in_bounds (min_x, max_x, min_y, max_y) boid =
  min_x <= boid.position.x && boid.position.x <= max_x &&
  min_y <= boid.position.y && boid.position.y <= max_y

let check_bounds (min_x, max_x, min_y, max_y) boid =
  let pos_x, v_x =
    if boid.position.x < min_x then (min_x, abs_float boid.speed.x)
    else if boid.position.x > max_x then (max_x, -. (abs_float boid.speed.x))
    else (boid.position.x, boid.speed.x)
  in
  let pos_y, v_y =
    if boid.position.y < min_y then (min_y, abs_float boid.speed.y)
    else if boid.position.y > max_y then (max_y, -.(abs_float boid.speed.y))
    else (boid.position.y, boid.speed.y)
  in
  { boid with position = { x = pos_x ; y = pos_y; };
              speed = { x = v_x; y = v_y; }; }

let new_boid position =
  signal separation
      default vzero
      gather (fun (me, boid) f_sep ->
        let sep = boid.position -: me.position in
        let distance = vnorm sep in
        if distance > epsilon_float then
          f_sep -: sep /: distance
        else f_sep)
  in
  signal cohesion
      default vzero, 0
      gather (fun (me, boid) (f_coh, n) ->
        let sep = boid.position -: me.position in
        barycenter n f_coh sep)
  in
  signal alignment
      default vzero, 0
      gather (fun (me, boid) (f_ali, n) ->
        let nspeed = vnorm boid.speed in
        if nspeed > epsilon_float then
           let norm_speed = boid.speed /: nspeed in
           barycenter n f_ali norm_speed
        else f_ali, n)
  in
  { id = gen_id ();
    position = position;
    speed = vzero;
    acceleration = vzero;
    s_separation = separation;
    s_cohesion = cohesion;
    s_alignment = alignment; }



let next_position me f_separation f_cohesion f_alignment =
  let acceleration =
    (separation_force *: f_separation) +:
      (cohesion_force *: f_cohesion) +:
      (alignment_force *: f_alignment)
  in
  let speed = (dt *: acceleration) +: me.speed in
  let position = (dt *: speed) +: me.position in
  check_bounds
    bounds
    { me with
      position = position;
      speed = speed;
      acceleration = acceleration; }


let rec process boid me step flock =
  (* await step; *)
  emit flock me;
  pause;
  let f_separation = pre ?me.s_separation in
  let f_cohesion, _ = pre ?me.s_cohesion in
  let f_alignment, _ = pre ?me.s_alignment in
  (* await me.s_separation(f_separation) /\ *)
  (*     me.s_cohesion(f_cohesion, _) /\ *)
  (*     me.s_alignment(f_alignment, _) in *)
  (* print_endline "Boid"; *)
  let next_me = next_position me f_separation f_cohesion f_alignment in
  run boid next_me step flock


let rec process add new_position step flock =
  await new_position (position) in
  run (add new_position step flock)
  ||
  let me = new_boid position in
  run (boid me step flock)

let dispatch me all =
  List.iter
    (fun boid ->
      let distance = vnorm (boid.position -: me.position) in
      if true or distance < separation_distance then begin
        emit boid.s_separation (boid, me);
        emit me.s_separation (me, boid)
      end;
      if true or distance < cohesion_distance then begin
        emit boid.s_cohesion (boid, me);
        emit me.s_cohesion (me, boid)
      end;
      if true or distance < alignment_distance then begin
        emit boid.s_cohesion (boid, me);
        emit me.s_cohesion (me, boid)
      end)
    all

let rec dispatcher all =
  begin match all with
  | [] -> ()
  | boid::flock ->
      dispatch boid flock;
      dispatcher flock
  end



let draw_boid b =
  let { x = x; y = y; } = b.position in
  Graphics.set_color Graphics.red;
  let x, y = int_of_float x, int_of_float y in
  Graphics.fill_circle x y 3


let process window draw =
  Graphics.set_window_title "Boids";
  Graphics.open_graph " 600x600";
  Graphics.auto_synchronize false;
  loop
    Graphics.synchronize ();
    await draw (all) in
    Graphics.clear_graph();
    List.iter draw_boid all
  end


signal step, flock;;
let process main =
  run window flock ||
  loop emit step; pause end ||
  for i=1 to boids_number dopar
    run boid (new_boid (vrandom 600. 600.)) step flock
  done ||
  loop
    await flock (all) in
    dispatcher all
  end ||
  loop
    pause;
  end

let () = run main
(* ;; *)
(* #suspend;; *)
(* #run main;; *)
(* #step ;; *)
(* pre ?flock;; *)
(* #step ;; *)
(* pre ?flock;; *)
(* #step ;; *)
(* pre ?flock;; *)
(* 1;; *)
