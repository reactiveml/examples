(***************************************************************)
(*                        ReactiveML                           *)
(*                                                             *)
(*                                                             *)
(*  Authors: Guillaume Baudart (guillaume.baudart@ibm.com)     *)
(*           Louis Mandel (louis.mandel@lri.fr)                *)
(*                                                             *)
(***************************************************************)

type vect =
    { x: float;
      y: float; }

let vzero =
  { x = 0.;
    y = 0.; }

let vone =
  { x = 1.;
    y = 1.; }

let vplus v1 v2 =
  { x = v1.x +. v2.x;
    y = v1.y +. v2.y; }
let ( +: ) = vplus


let vminus v1 v2 =
  { x = v1.x -. v2.x;
    y = v1.y -. v2.y; }
let ( -: ) = vminus

let vscale a v =
  { x = a *. v.x;
    y = a *. v.y; }
let ( *: ) = vscale
let ( /: ) = fun v a -> vscale (1. /. a) v

let vmult v1 v2 =
  { x = v1.x *. v2.x;
    y = v1.y *. v2.y; }
let ( **: ) = vmult

let vnorm2 v =
  let m = v **: v in
  m.x +. m.y

let vnormalize2 v =
  if v = vzero then vzero
  else v /: (vnorm2 v)

let vnorm v =
  sqrt (vnorm2 v)

let vcos v1 v2 =
  let n1 = sqrt (vnorm v1) in
  let n2 = sqrt (vnorm v2) in
  (v1.x *. v2.x +. v1.y *. v2.y) /. (n1 *. n2)

let vrandom xmax ymax =
  { x = Random.float xmax;
    y = Random.float ymax; }

let vrandom_sphere center radius =
  let n = Random.float radius in
  let a = Random.float (2. *. 3.14) in
  vrandom (n *. cos a) (n *. sin a)

let vprint v =
  print_endline ("("^(string_of_float v.x)^","^(string_of_float v.y)^")")

let gen_id =
  let cpt = ref 0 in
  fun () ->
    incr cpt;
    !cpt

let barycenter n b v =
  let b = (v +: ((float) n) *: b) /: ((float) (n + 1)) in
  b, n + 1

let damping limit v =
  let n = vnorm v in
  if n > limit then (limit /. n) *: v
  else v

type boid =
    { id: int;
      position: vect;
      speed: vect;
      acceleration: vect;
      s_separation: ((boid * boid), vect) event;
      s_cohesion: ((boid * boid), (vect * int)) event;
      s_alignment: ((boid * boid), (vect * int)) event;}

let boids_number = 50
let speed_limit = 2.
let acceleration_limit = 0.5
let vision_angle = -1.0
let separation_distance = 10.
let alignment_distance = 50.
let cohesion_distance = 100.
let separation_force = 10.0
let cohesion_force = 1.0
let alignment_force = 0.1
let dt = 1.
let bounds = (0., 600., 0., 600.)

let boid_angle b1 b2 =
  let v1 = b1.speed in
  let v2 =
    { x = b2.position.x -. b1.position.x;
      y = b2.position.y -. b1.position.y; }
  in
  vcos v1 v2


let in_bounds (min_x, max_x, min_y, max_y) boid =
  min_x <= boid.position.x && boid.position.x <= max_x &&
  min_y <= boid.position.y && boid.position.y <= max_y

let check_bounds (min_x, max_x, min_y, max_y) boid =
  let pos_x, v_x =
    if boid.position.x < min_x then (min_x, abs_float boid.speed.x)
    else if boid.position.x > max_x then (max_x, -. (abs_float boid.speed.x))
    else (boid.position.x, boid.speed.x)
  in
  let pos_y, v_y =
    if boid.position.y < min_y then (min_y, abs_float boid.speed.y)
    else if boid.position.y > max_y then (max_y, -.(abs_float boid.speed.y))
    else (boid.position.y, boid.speed.y)
  in
  { boid with position = { x = pos_x ; y = pos_y; };
              speed = { x = v_x; y = v_y; }; }

let new_boid position =
  signal separation
      default vzero
      gather (fun (me, boid) f_sep ->
        let sep = boid.position -: me.position in
        f_sep -: sep)
  in
  signal cohesion
      default vzero, 0
      gather (fun (me, boid) (f_coh, n) ->
        let sep = boid.position -: me.position in
        barycenter n f_coh sep)
  in
  signal alignment
      default vzero, 1
      gather (fun (me, boid) (f_ali, n) ->
        (* f_ali +: boid.speed, n *)
        (* let nspeed = vnorm boid.speed in *)
        (* if nspeed > epsilon_float then *)
        barycenter n f_ali boid.speed)
        (* else f_ali, n) *)
  in
  { id = gen_id ();
    position = position;
    speed = vrandom_sphere vzero speed_limit;
    acceleration = vzero;
    s_separation = separation;
    s_cohesion = cohesion;
    s_alignment = alignment; }




let next_position me f_separation f_cohesion f_alignment =
  let acceleration =
    (separation_force *: (vnormalize2 f_separation)) +:
      (cohesion_force *: (vnormalize2 f_cohesion)) +:
      (alignment_force *: (vnormalize2 f_alignment))
  in
  let acceleration = damping acceleration_limit acceleration in
  let speed = (dt *: acceleration) +: me.speed in
  let speed = damping speed_limit speed in
  let position = (dt *: speed) +: me.position in
  check_bounds
    bounds
    { me with
      position = position;
      speed = speed;
      acceleration = acceleration; }

let rec process boid me step flock =
  (* await step; *)
  emit flock me;
  pause; pause;
  let f_separation = pre ?me.s_separation in
  let f_cohesion, _ = pre ?me.s_cohesion in
  let f_alignment, _ = pre ?me.s_alignment in
  let next_me = next_position me f_separation f_cohesion f_alignment in
  run boid next_me step flock


let rec process add new_position step flock =
  await new_position (position) in
  run (add new_position step flock)
  ||
  let me = new_boid position in
  run (boid me step flock)

let dispatch me all =
  List.iter
    (fun boid ->
      let distance = vnorm2 (boid.position -: me.position) in
      if (boid_angle me boid > vision_angle) then begin
        if distance < separation_distance ** 2. then begin
          emit boid.s_separation (boid, me);
          emit me.s_separation (me, boid)
        end;
        if distance < cohesion_distance ** 2. then begin
          emit boid.s_cohesion (boid, me);
          emit me.s_cohesion (me, boid)
        end;
        if distance < alignment_distance ** 2. then begin
          emit boid.s_alignment (boid, me);
          emit me.s_alignment (me, boid)
        end
      end)
    all

let rec dispatcher all =
  begin match all with
  | [] -> ()
  | boid::flock ->
      dispatch boid flock;
      dispatcher flock
  end



let draw_boid b =
  Graphics.set_color Graphics.red;
  let pos = b.position in
  let tail = b.position -: (10. *: b.speed) in
  Graphics.fill_circle
    (int_of_float pos.x)
    (int_of_float pos.y)
    2;
  Graphics.draw_segments
    [| int_of_float pos.x,
       int_of_float pos.y,
       int_of_float tail.x,
       int_of_float tail.y|]


let process window draw =
  Graphics.set_window_title "Boids";
  Graphics.open_graph " 600x600";
  Graphics.auto_synchronize false;
  loop
    Graphics.synchronize ();
    await draw (all) in
    Graphics.clear_graph();
    List.iter draw_boid all
  end
  ||
  loop
    let _ = Graphics.wait_next_event [Graphics.Poll] in
    pause
  end


signal step, flock;;
let process main =
  run window flock ||
  loop emit step; pause; pause end ||
  for i=1 to boids_number dopar
    run boid (new_boid (vrandom 600. 600.)) step flock
  done ||
  loop
    await flock (all) in
    dispatcher all
  end ||
  loop
    pause;
  end

let () = run main
